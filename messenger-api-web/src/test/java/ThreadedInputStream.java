/**
 * Created by Y.B.H(mium2) on 2015. 10. 16..
 */

import org.apache.commons.io.IOUtils;

import java.io.*;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Allows to read data previously generated by ThreadedOutputStream. This class instance
 * works in single thread and retrieves data from interleaved stream, written by single
 * thread. The raw source stream is divided on entries, depending on how many threads
 * were writing to the ThreadedOutputStream.
 *
 * @author l0co@wp.pl
 */
public class ThreadedInputStream extends InputStream {

    protected DataInputStream source;
    protected byte entry;

    protected int bytesToRead = 0; // how many bytes can we read already from current data block?

    protected long pos = 0;

    /**
     * Creates the input stream.
     *
     * @param source Newly instantiated, clean source input stream to raw data
     *      produced by ThreadedOutputStream.
     * @param entry Entry number. There can be many entries in source stream (0, 1, 2... etc,
     *      depending on count of writing threads).
     * @throws EOFException If there's no such entry yet (you need to manually close source then).
     */
    public ThreadedInputStream(InputStream source, byte entry) throws IOException {
        super();

        if (entry>Byte.MAX_VALUE)
            throw new IOException("Cannot serve for more than Byte.MAX_VALUE threads");

        this.source = new DataInputStream(source);
        this.entry = entry;
        lookupNextBlock();
    }

    protected void lookupNextBlock() throws IOException {
        while (true) {
            byte currentEntry = source.readByte();

            if (currentEntry==entry) {
                // found next entry datablock
                bytesToRead = source.readInt();
                break;
            } else {
                // found next entry, but for different datablock (look for another)
                int blockSize = source.readInt();
                long toSkip = blockSize;
                while (toSkip>0) {
                    long skip = source.skip(toSkip);
                    if (skip<0)
                        throw new EOFException("Cannot skip full datablock");
                    toSkip -= skip;
                }
            }
        }
    }

    @Override
    public int read() throws IOException {
        if (bytesToRead<=0)
            try {
                lookupNextBlock();
            } catch (EOFException e) {
                return -1;
            }

        bytesToRead--;
        return source.read();
    }

    @Override
    public void close() throws IOException {
        source.close();
    }

    // test
    public static void main(String[] args) throws IOException {
        File f = new File("threados");

        ThreadGroup group = new ThreadGroup("threados");

        // read some data by threads
        Map<Byte, ByteArrayOutputStream> outmap = new LinkedHashMap<Byte, ByteArrayOutputStream>();

        try {
            byte i = 0;
            while (true) {
                InputStream source = new BufferedInputStream(new FileInputStream(f));
                try {
                    final ThreadedInputStream is = new ThreadedInputStream(source, i++);
                    final ByteArrayOutputStream out = new ByteArrayOutputStream();
                    outmap.put(i, out);

                    new Thread(group, new Runnable() {
                        @Override
                        public void run() {
                            try {
                                IOUtils.copy(is, out);
                                is.close();
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    }).start();
                } catch (EOFException e) {
                    source.close();
                    break;
                }
            }
        } catch (EOFException e) {} // no more interleaved streams

        // wait for threads
        try {
            synchronized (group) {
                if (group.activeCount()>0)
                    group.wait();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        for (byte b: outmap.keySet()) {
            byte[] ba = outmap.get(b).toByteArray();
            System.out.println(b+" ["+ba.length+"]: "+dumpByteArray(ba));
        }
    }

    public static String dumpByteArray(byte[] b) {
        StringBuffer sb = new StringBuffer();
        int i = 0;
        byte crc = 0;
        for (byte b1: b) {
            if (i++<20) {
                if (b1<10 && b1>=0)
                    sb.append(0);
                sb.append((int) b1 & 0xFF);
                sb.append(',');
            }

            if (i==b.length) {
                if (crc==b1)
                    sb.append("crc ok");
                else
                    sb.append("crc error");
            } else
                crc+=b1;
        }
        return sb.toString();
    }

}
